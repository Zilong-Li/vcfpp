#+title: vcfpp: a C++ API for scripting rapid variant analysis
#+setupfile: latex.org
#+language: en
#+startup: show2levels indent hidestars hideblocks
#+options: title:nil toc:nil H:4 author:nil num:nil
#+bibliography: "ref.bib"

#+begin_export latex
\author{Zilong Li
\thanks{Zilong Li: Section for Computational and RNA Biology, Department of Biology, University of Copenhagen. \\
Email: zilong.dk@gamil.com.}}
\begin{titlepage} \maketitle
  \begin{abstract}
  Given the complexity and popularity of the VCF/BCF format as well as
  ever-growing data size, there is always a need for fast and flexible
  methods to manipulate it in different programming languages. Static
  languages like C++ has the superiority of performance, and modern
  C++ standards strive to provide growing standard library for
  developing program quickly and easily. This work presents vcfpp, a
  C++ API of htslib in a single file, providing an intuitive interface
  to manipulate VCF/BCF files rapidly and safely, as well as being
  portable. Additionally, this work introduces the vcfppR package to
  demonstrate the usage of developing R packages using vcfpp
  seamlessly and esaily for analyzing and visualizing genomic
  variations in R. In the Benchmarking, the vcfppR shows the same
  performance as the C++ version, and shows faster speed than cyvcf2
  when streaming variant analysis. Also, in a two-step setting, the
  vcfppR shows faster speed of both loading VCF contents and
  processing genotypes than the vcfR package. Finally, some useful
  command line tools using vcfpp are available to demonstrate the
  easy-to-use of vcfpp in writing a C++ program.
  \end{abstract}
\end{titlepage}
#+end_export

* Introduction

Many efforts have been contributed by computational biologists, aim
for making analyses of genomics variants no pain. The variants are
typically stored in the VCF format, which becomes the standard for
representing genetic variation information with complicated
specification [cite:@danecek2011]. Later on, as the ever-growing
data size, the BCF format is designed to query and store big data
efficiently. The C API of htslib provide the full functionalities to
manipulate the VCF and BCF format for both compressed and
uncompressed files. As the C API is hard to use for in-proficient
programmers, API of other languages are invented. Existing popular
libraries include vcfR[cite:@brian2017] for R, cyvcf2
[cite:@pedersen2017a] for Python, hts-nim [cite:@pedersen2018] for
Nim and vcflib [cite:@garrison2022] for C++. All are valuable for
corresponding community but not perfect. In particular, vcflib is
both an API and a large collection of command line tools, with the
primary disadvantage being not supporting the BCF format. It is
noteworthy that many methods written in C++ designed for large
sample size can not even input the BCF file tailed for big data or
the compressed VCF file like Syllbable-PBWT [cite:@wang2023]. The
motivation of vcfpp is to offer full functionalities as htslib and
provide simple and safe API in a single header file that can be
easily integrated for writing program quickly in C++ and R.

* Methods 

vcfpp is implemented as a single header file for being easily
integrated and compiled. There are four core class for manipulating
the uncompressed and compressed VCF/BCF files as summarized in Table
[[tb:class]].

#+caption: vcfpp capabilities and implemented C++ class
#+name: tb:class
|---------------------------------+-----------|
| Capability                      | Class     |
|---------------------------------+-----------|
| VCF/BCF read                    | BcfReader |
| VCF/BCF write                   | BcfWriter |
| VCF/BCF variants and operations | BcfRecord |
| VCF/BCF header and operations   | BcfHeader |
|---------------------------------+-----------|

* Results

To demonstrate the power and performance of vcfpp, the following
sections illustrate commonly used features of vcfpp and highlight
the vcfppR package as an example of vcfpp working with R.

** C++ API

In this example (Listing [[list1]]), we count the number of
heterozygous sites for each sample across all records. The
following code first includes a single vcfpp.h file (line 1),
opens a compressed BCF file constrained to 3 samples and region
"chr21" (line 2), and creates a variant record associated with the
header information in the BCF (line 3). Then it defines several
types of objects to collect the results we want (line 4-6). Taking
advantage of generic templates in C++, the type of field like
genotype can be very flexible regarding memory consumption. Then
it starts iterating over the BCF file and processes each variant
record in the loop (line 7). We ignore variants of other types
(INDEL, SV), or with /FILTER/ not being "PASS", or with /QUAL/ value
smaller than 9, while we can also retrieve more information of the
variant and do filtering (line 9-10). Finally, we count the number
of heterozygous variant for each diploid sample (line 11-13). The
core is just 12 lines.

#+name: list1
#+caption: Counting the number of heterozygous genotypes for 3 samples on chr21
#+attr_latex: :options captionpos=t
#+begin_src C++ -n
#include <vcfpp.h>
vcfpp::BcfReader vcf("bcf.gz", "chr21", "id1,id2,id3"); 
vcfpp::BcfRecord var(vcf.header); // create a variant object
vector<int> gt; // genotype can be bool, char or int type
vector<int> hetsum(vcf.nsamples, 0); // store the het counts
float hwe, exchet; // capture more INFO
while(vcf.getNextVariant(var)){
  var.getGenotypes(gt);
  var.getINFO("HWE",hwe), var.getINFO("ExcHet",exchet);//more
  if(!var.isSNP()||var.QUAL()<9||var.FILTER()!="PASS")continue; 
  assert(var.ploidy()==2); // make sure it is diploidy
  for(int i=0; i<gt.size()/2; i++) 
    hetsum[i] += abs(gt[2*i+0] - gt[2*i+1])==1;
}
#+end_src

\newpage

** Working with R

While vcfpp is very simple for writing a C++ program, a single C++
header file can be easily integrated into popular script languages
like R and Python etc. The process of finding biological insights
from variant information always involves statistical modeling and
visualization, which is what R designed for. Therefore, I develop
the vcfppR package to demonstrate how vcfpp can work with R
seamlessly by using Rcpp [cite:@eddelbuettel2011]. With the basic
knowledge of C++ and Rcpp, we can turn the C++ code in Listing
[[list1]] into the Rcpp function to obtain a list of the number
heterzygous sites per sample along with the IDs (listing [[list2]]),
which can be compiled and called in R (Listing [[list3]]). As such, we
can further proccess and visualize the results efficiently in R,
such as stratifying the results by populations given external
labels of each sample and visualizing them in boxplot (supp Fig1).

#+name: list2
#+caption: vcfpp-hets.cpp
#+attr_latex: :options captionpos=t
#+begin_src C++
#include <Rcpp.h>
#include <vcfpp.h>
using namespace Rcpp;
using namespace std;
// [[Rcpp::export]]
List heterozygosity(std::string vcffile,
                    std::string region,
                    std::string samples) {
  // here copy the lines 2-14 in listing 1.
  return List::create(Named("samples")=vcf.header.getSamples(),
                      Named("hets")=hetsum);
}
#+end_src

#+name: list3
#+caption: The R code compiles and calls the vcfpp-het.cpp
#+attr_latex: :options captionpos=t
#+begin_src R
library(Rcpp)
sourceCpp("vcfpp-hets.cpp")
heterozygosity("bcf.gz", "chr21","id1,id2,id3");
#+end_src

** The vcfppR package

The vcfppR package is developed and powered by the vcfpp API. For
parsing the VCF in R, the /vcftable/ function can read contents of
the VCF into the R data type rapidly with fine control of the
region, the samples, the variant types, the INFO / FORMAT column
and the filters. For instance, the code in Listing 4 parses the
read depth per variant (DP) in the raw called VCF by the 1000
Genomes Project through the URL link, restricting to 3 samples
with variants in "chr21:1-10000000" region of SNP type and passing
FILTER, as well as discarding the INFO column in the returned
list. Consequently, the visual summarization is done by using
/barplot/ in R.

#+caption: vcftable in vcfppR
#+attr_latex: :options captionpos=t
#+begin_src R
library(vcfppR)
vcffile <- "https://ftp.1000genomes.ebi.ac.uk/vol1/ftp/data_collections/1000G_2504_high_coverage/working/20201028_3202_raw_GT_with_annot/20201028_CCDG_14151_B01_GRM_WGS_2020-08-05_chr21.recalibrated_variants.vcf.gz"
vcf <- vcftable(vcffile, region="chr21:1-10000000", samples="NA12878,HG00118,HG00119", format="DP", vartype="snps", pass = TRUE, info = FALSE)
boxplot(vcf$dp, names=vcf$samples, ylab="Read Depth (DP)")
#+end_src

Furthermore, as characterization of the variations is an essential
task in understanding the genome, I showcase the /vcfsummary/
function in summarizing the variations in the VCF by reproducing
the statistics in the 1KGP paper [cite:@byrska-bishop2022].

** Benchmarking

In addition to simplicity and portability, I showcase the
performance of vcfpp and vcfppR. In the benchmarking, I performed
the same task as the cyvcf2 paper, that is counting heterozygous
genotypes per sample using code in Listing 1. As shown in Table
[[tb:counthets]], the vcfppR has the same performance as the vcfpp C++
API, while the cyvcf2 script is $1.4\times$ slower than the vcfppR
script. In the streaming setting, all three scripts use little RAM
for only loading one variant into memory. However, R packages like
vcfR and data.table usually load all tabular data into memory
first and perform analysis later. Additionaly, I develop /vcftable/
function in vcfppR to load whole VCF content in R for such
two-step comparison. Notably, the vcfppR is only $1.8\times$
slower compared to $70\times$, $85\times$ slower for vcfR and
data.table respectively. This is because genotype values returned
by both vcfR and data.table::fread are characters, which are very
slow to parse. In contrast, with vcfppR, integer matrix of
genotypes can be returned to R directly for fast
computation. Importantly, vcfpp and vcfppR offer the users the
full functionalities of htslib, such as supporting BCF, selecting
samples, regions and variant types. A rapid query of VCF content
in vcfppR can be achieved by passing a region parameter to
/vcftable/.

#+caption: Performance of counting heterozygous genotypes per sample in the 1000 Genome Project for chromosome 21. (*) used by loading data in two-step strategy.
#+name: tb:counthets
#+attr_latex: :align lllllll :placement [H]
|-------------+------------+-------+----------+---------+-----------|
| API/Package | Time (s)   | Ratio | RAM (Gb) | CPU (%) | Strategy  |
|-------------+------------+-------+----------+---------+-----------|
| vcfpp       | 118        |   1.0 |    0.006 |      99 | streaming |
| vcfppR      | 118        |   1.0 |    0.076 |     101 | streaming |
| cyvcf2      | 165        |   1.4 |    0.038 |     101 | streaming |
| vcfppR      | 205*+10    |   1.8 |     64.7 |     100 | two-step  |
| vcfR        | 678*+1147  |  15.5 |     97.5 |     100 | two-step  |
| data.table  | 263*+11243 |  97.5 |     77.3 |     200 | two-step  |
|-------------+------------+-------+----------+---------+-----------|

* Discussion

I have developed vcfpp, a fast and flexible C++ API for scripting
high-performance genetic variant analyses. Its simplicity and
portability can be very useful for both developing packages and
writing daily used scripts. Many packages written in C++ using
customized VCF parser can be replaced with vcfpp to offer more
functionalities. For instance, imputation software STITCH
[cite:@davies2016] and QUILT [cite:@davies2021] are using vcfpp to
parse large reference panel in VCF/BCF format. Also, there are some
useful command line tools available, such as a modified
Syllable-PBWT with the compressed VCF/BCF as input.

* Software and Code

The latest release of vcfpp.h and documentation can be found at
https://github.com/Zilong-Li/vcfpp. Scripts for Benchmarking can be
found at https://github.com/Zilong-Li/vcfpp/tree/main/scripts. The
vcfppR package is available at https://github.com/Zilong-Li/vcfppR.

* Acknowledgments

I would like to thank Anders Albrechtsen at Copenhagen University
and Robert W Davies at Oxford University for helpful comments. They
are Statisticians working on genetics as well as R enthusiast, whom
I work with and learn a lot from.

* Funding

This work is supported by the Novo Nordisk 462 Foundation
(NNF20OC0061343).

#+print_bibliography:
\newpage
\appendix

* Supplementary

** Example

#+caption: vcfsummary in vcfppR
#+attr_latex: :options captionpos=t
#+begin_src R
library(vcfppR)
svfile <- "https://ftp.1000genomes.ebi.ac.uk/vol1/ftp/data_collections/1000G_2504_high_coverage/working/20210124.SV_Illumina_Integration/1KGP_3202.gatksv_svtools_novelins.freeze_V3.wAF.vcf.gz"
sv <- vcfsummary(svfile, svtype = TRUE)
par(mfrow=c(1,3)) ## layout in plots
allsvs <- sv$summary[-1]
bar <- barplot(allsvs, ylim = c(0, 1.1*max(allsvs)),
               main = "Variant Count (all SVs)")
text(bar, allsvs+4500, paste0("n: ", allsvs))
boxplot(sv[c("DEL","DUP", "CNV", "INS","INV","CPX","CTX")],
        main = "SVs per Genome stratified by SV types")
ped <- read.table("https://ftp.1000genomes.ebi.ac.uk/vol1/ftp/data_collections/1000G_2504_high_coverage/20130606_g1k_3202_samples_ped_population.txt", h=T)
ped <- ped[order(ped$Superpopulation),]
supers <- unique(ped$Superpopulation)
o <- lapply(supers, function(pop) {
  id <- subset(ped, Superpopulation == pop)[,"SampleID"]
  ord <- match(id, samples)
  sapply(sv[-c(1,2)], "[", ord)
})
names(o) <- supers
s <- as.data.frame(lapply(o, colMeans))
barplot(colSums(s),
        main = "SVs per Genome stratified by populations")
#+end_src

[[file:dp.pdf]]

* Local setup :noexport:
Local Variables:
org-latex-listings: t
End:
