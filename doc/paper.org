#+title: vcfpp: a C++ API for scripting rapid variant analysis
#+setupfile: latex.org
#+language: en
#+startup: show2levels indent hidestars hideblocks
#+options: title:nil toc:nil H:4 author:nil
#+bibliography: "ref.bib"

#+begin_export latex
\author{Zilong Li
\thanks{Zilong Li: Section for Computational and RNA Biology, Department of Biology, University of Copenhagen. \\
Email: zilong.dk@gamil.com.}}
\begin{titlepage} \maketitle
  Given the complexity and popularity of the VCF/BCF format as well as
  ever-growing data size, there is always a need for fast and flexible
  methods to manipulate it in different programming languages. Static
  languages like C++ has the superiority of performance as C, and
  modern C++ standards strive to provide enlarged standard library for
  developing program quickly and easily. In this work, we present
  vcfpp, a C++ API of htslib, providing a rapid and intuitive
  interface to manipulate VCF/BCF files safely and as easily as
  writing python script. We demonstrate an example of how minimal
  vcfpp code can read/write variant records rapidly. Additionally, we
  demonstrate how vcfpp can be useful to Statisticians analyzing
  genetic variants in R. In the benchmarking, a simple R script using
  vcfpp API shows lower memory footprint and fast speed than scripts
  using vcfR and cyvcf2. Command line tool using vcfpp is available
  for performaning PBWT-based analysis using large-scale reference
  panel stored in compressed BCF format.
\end{titlepage}
#+end_export

* Introduction

Many efforts have been contributed by computational biologists, aim
for making analyses of genetic variants no pain. The genetic
variants are typically stored in the VCF format, which becomes the
standard for representing genetic variation information with
complicated specification [cite:@danecek2011]. Later on, as the
ever-growing data size, BCF format is designed to query and store
big data efficiently. The C API of htslib provide the full
functionalities to manipulate VCF and BCF format for both compressed
and uncompressed files. As the C API is hard to use for
in-proficient programmers, API of other languages are
invented. Existing popular libraries include vcfR[cite:@brian2017]
for R, cyvcf2 for python [cite:@pedersen2017a], hts-nim
[cite:@pedersen2018] for nim and vcflib for C++
[cite:@garrison2022]. All are useful for corresponding language
community and have advantages and disadvantages. In particular,
vcflib is both an API and a large collection of command line tools
to manipulate VCF file, with the main disadvantage being not
supporting BCF file. Many methods designed for large sample size can
not even take the BCF file that is tailed for big data as input like
Syllbable-PBWT [cite:@wang2023]. The motivation of vcfpp is to offer
full functionalities as htslib and provide easy-to-use API in a
single header file that can be easily integrated for writing scripts
quickly in C++, python and R.

* Features 

vcfpp is implemented as a single header file for being easily
intergrated and compiled. There are four core classes for
manipulating VCF/BCF as summarized in Table [[tb:class]].

#+caption: vcfpp capabilities and implemented C++ class
#+name: tb:class
|---------------------------------+-----------|
| Capability                      | Class     |
|---------------------------------+-----------|
| VCF/BCF read                    | BcfReader |
| VCF/BCF write                   | BcfWriter |
| VCF/BCF variants and operations | BcfRecord |
| VCF/BCF header and operations   | BcfHeader |
|---------------------------------+-----------|

* Usage

In an effort to demonstrate the power and performance of vcfpp, the
following sections highlight typical VCF analyses and illustrate
commonly used features in vcfpp. Other examples and further details
of the vcfpp can be found at https://github.com/Zilong-Li/vcfpp.

** Python-like API

In this example, we count the number of heterozygous sites for
each sample in all records. The following code first includes a
single vcfpp.h file (line 1), opens a compressed BCF file with subset
samples and a constrained region (line 2), and creates a
variant record object associated with the header information in
the BCF (line 3). Then it defines several types of objects to
collect the results we want (line 4-6). Taking advantage of
generic templates in C++, type of genotype can be very
flexible. Then it starts iterating over the BCF file and process
each variant record in the loop (line 7). We ignore variant of
other types (INDEL, SV), with missing genotypes and with QUAL
value smaller than 9, while we can also retrieve more information
of the variant and do filtering (line 9-10). Finally, we count the
heterozygous sites for each diploid sample (line 11-13). The core
is just 13 lines.

#+caption: Counting heterozygous genotypes per sample on chr21
#+attr_latex: :options captionpos=t
#+begin_src C++ -n
#include <vcfpp.h>
vcfpp::BcfReader vcf("bcf.gz", "chr21", "id1,id2,id3"); 
vcfpp::BcfRecord var(vcf.header); // create a variant object
vector<char> gt; // genotype can be of bool, char or int type
vector<int> hetsum(vcf.nsamples, 0); // store the het counts
float hwe, exchet; // capture more INFO
while(vcf.getNextVariant(var)){
  var.getGenotypes(gt);
  var.getINFO("HWE",hwe), var.getINFO("ExcHet",exchet);//more
  if(!var.isSNP()||!var.isNoneMissing()||var.QUAL()<9) continue; 
  assert(var.ploidy()==2); // make sure it is diploidy
  for(int i=0; i<gt.size()/2; i++) 
    hetsum[i] += abs(gt[2*i+0] - gt[2*i+1]);
}
#+end_src

\newpage

** Working with R

While vcfpp is very simple for writing a C++ program, a single C++
header file can be easily integrated into popular script languages
like Python and R etc. The process of finding biological insights
from variants information always involves statistical model, and
Statisticians prefer analyzing and visualizing data in R. In this
example, we demonstrate how vcfpp can work with R seamlessly by
using Rcpp [cite:@eddelbuettel2011]. In the "vcfpp-r.cpp" file, we
write a simple C++ function to get a list of genotypes and its
quality with only changing the output objects to Rcpp::List. Then
we can easily call the /readbcf/ function to proceed further
statistical tests in R.

#+caption: vcfpp-r.cpp
#+attr_latex: :options captionpos=t
#+begin_src C++
#include <Rcpp.h>
#include <vcfpp.h>
using namespace Rcpp;
using namespace std;
// [[Rcpp::export]]
List readbcf(string vcffile) {
    vcfpp::BcfReader vcf(vcffile);
    vcfpp::BcfRecord var(vcf.header);
    vector<vector<int>> GT, GQ;
    vector<int> gt, gq;
    while (vcf.getNextVariant(var)) {
        var.getGenotypes(gt);
        var.getFORMAT("GQ",gq); // can get all other tags
        GT.push_back(gt), GQ.push_back(gq);
    }
    return List::creat(wrap(GT),wrap(GQ)); 
}
#+end_src

#+caption: The R code compiles and calls the above C++ code
#+attr_latex: :options captionpos=t
#+begin_src R
library(Rcpp)
sourceCpp("vcfpp-r.cpp")
out <- readbcf("bcf.gz")
## next perform statistical modeling 
#+end_src

* Benchmarking

In addition to simplicity and flexibility, we show how fast and
efficient scripts using vcfpp can be. In the benchmarking, we
performed the same task as in cyvcf2 paper. As shown in Table [[tb:counthets]], the python script
using cyvcf2 is $1.3\times$ slower than the R script using vcfpp,
and both using little RAM.

#+caption: Performance of counting heterozygous genotypes per sample in the 1000 Genome Project for chromosome 21. (*) used by /sourceCpp/ function.
#+name: tb:counthets
#+attr_latex: :align lllll :placement [H]
|-------------------+-----------+-------+-------------+----------------|
| API               | Time (s)  | Ratio | RAM (Gb)    | script         |
|-------------------+-----------+-------+-------------+----------------|
| vcfpp::BcfReader  | 115+3@    |   1.0 | 0.071+0.28@ | test-vcfpp-1.R |
| vcfpp::BcfReader  | 257+3@    |   1.0 | 0.071+0.28@ | test-vcfpp-2.R |
| cyvcf2::VCF       | 154       |   1.3 | 0.035       | test-cyvcf2.py |
| vcfR::read.vcfR   | 577+6630* |  61.1 | 48+49*      | test-vcfR.R    |
| data.table::fread | 272       |   1.1 |  40.5       | test-fread.R   |
|-------------------+-----------+-------+-------------+----------------|

As vcfR first loads the whole VCF contents into R objects and
performs analyses afterwards , it is not preferable to use vcfR for
this task. In the second task, we compare the performance of
converting all contents in the VCF file into R tables. However,
regarding the best practice of data analysis in R, we usually want
to inspect the part of the data table to make further decisions. In
this regard, vcfpp has the full functionalities of htslib that is
supporting reading BCF, subsetting samples and regions. A /head/
lookup can be achieved by passing a region parameter.

* Discussion

We have developed vcfpp, a fast and flexible C++ API for scripting
high-perfomance genetic variant analyses. Its easy-to-use can be
very useful for both package developers and writing of daily used
scripts.

* Software and Code

The latest release of vcfpp.h can be downloaded from
https://github.com/Zilong-Li/vcfpp/releases. Scripts for
Benchmarking can be found here
https://github.com/Zilong-Li/vcfpp/tree/main/scripts.

#+print_bibliography:

* Local setup :noexport:
Local Variables:
org-latex-listings: t
End:
